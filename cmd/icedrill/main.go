package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/davecgh/go-spew/spew"
	"github.com/pkg/errors"
)

var logger = log.New(os.Stderr, "[icedrill] ", log.LstdFlags)

const HandlerPrefix = "handle"

func main() {
	aggregate, err := findAggregate("Account", "UUID")
	if err != nil {
		panic(err)
	}

	spew.Dump(aggregate)

	templateFile(
		"/home/robert/src/icedrill/generator/placeholder/common.tpl",
		"/home/robert/src/icedrill/_examples/1-simple/domain_generated.go",
		aggregate,
	)
	templateFile(
		"/home/robert/src/icedrill/generator/eventstore/sqlx/template.tpl",
		"/home/robert/src/icedrill/_examples/1-simple/repo_generated.go",
		aggregate,
	)
}

func templateFile(
	file string,
	dest string,
	aggregate aggregateData,
) {
	commnTpl, err := ioutil.ReadFile(file)
	if err != nil {
		panic(err)
	}
	commnTplStr := string(commnTpl)

	t := template.Must(template.New("tpl").Parse(commnTplStr))

	b := bytes.NewBuffer(nil)

	if err := t.Execute(b, aggregate); err != nil {
		panic(err)
	}

	err = ioutil.WriteFile(
		dest,
		append([]byte("// Code generated by icedrill. DO NOT EDIT.\n\n"), b.Bytes()...),
		0644,
	)
	if err != nil {
		panic(err)
	}
}

type aggregateData struct {
	AggregatePackage string
	AggregateType    string
	IDGetter         string
	IDType           string
	Events           []string
	HaveEventSourced bool
}

func findAggregate(name string, idGetterName string) (aggregateData, error) {
	aggregate := aggregateData{
		IDGetter:      idGetterName,
		AggregateType: name,
	}

	err := filepath.Walk(".", func(path string, fi os.FileInfo, err error) error {
		if fi.IsDir() {
			return nil
		}

		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			panic(err)
		}

		fmt.Println(f.Name)
		aggregate.AggregatePackage = f.Name.Name

		for _, decl := range f.Decls {
			switch typeDecl := decl.(type) {
			case *ast.GenDecl:
				for _, spec := range typeDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						logger.Println(typeSpec, "is not *ast.TypeSpec")
						continue
					}

					if typeSpec.Name.Name != name {
						logger.Println(typeSpec.Name, "is not", name)
						continue
					}

					structDecl, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						// todo - error?
						logger.Println(typeSpec.Name, "is not struct")
						continue
					}

					for _, field := range structDecl.Fields.List {
						// todo - validate if proper field is present
						fmt.Println("field", field.Names, field.Type)
					}

					fmt.Println(typeSpec.Name)
				}
			case *ast.FuncDecl:
				logger.Println("Found func", typeDecl.Name)

				receiverType, err := getReceiverType(typeDecl)
				if err != nil {
					logger.Println(typeDecl.Name, ":", err)
					continue
				}

				if receiverType != name {
					logger.Println(typeDecl.Name, "have different receiver (", receiverType, ") skipping")
					continue
				}

				if strings.HasPrefix(typeDecl.Name.Name, HandlerPrefix) {
					logger.Println(typeDecl.Name, "is event handler")
					aggregate.Events = append(aggregate.Events, strings.ReplaceAll(typeDecl.Name.Name, HandlerPrefix, ""))
				}
				if typeDecl.Name.Name == idGetterName {
					logger.Println(typeDecl.Name, "is id getter")

					t, err := getType(typeDecl.Type.Results.List[0].Type)
					if err != nil {
						// todo - handle in better way
						panic(err)
					}

					if aggregate.IDType != "" {
						panic("IDType already set")
					}
					aggregate.IDType = t
				}
			}
		}

		return nil
	})

	if err != nil {
		return aggregateData{}, err
	}

	return aggregate, nil
}

func getReceiverType(typeDecl *ast.FuncDecl) (string, error) {
	if typeDecl.Recv == nil {
		return "", fmt.Errorf("%s have no receiver (nil)", typeDecl.Name)
	}

	if len(typeDecl.Recv.List) == 0 {
		return "", fmt.Errorf("%s have no receiver (empty list)", typeDecl.Name)
	}

	receiver := typeDecl.Recv.List[0].Type

	return getType(receiver)
}

func getType(expr ast.Expr) (string, error) {
	switch receiverType := expr.(type) {
	case *ast.StarExpr:
		return receiverType.X.(*ast.Ident).Name, nil
	case *ast.Ident:
		return receiverType.Name, nil
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", receiverType.X.(*ast.Ident), receiverType.Sel.Name), nil
	}

	return "", errors.Errorf("unsupported receiver %#v", expr)
}
