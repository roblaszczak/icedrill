package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/davecgh/go-spew/spew"
	"github.com/pkg/errors"
)

var logger = log.New(os.Stderr, "[icedrill] ", log.LstdFlags)

const HandlerPrefix = "handle"
const FunctionHandlersPlaceholder = "//[GENERATE: EVENT HANDLERS]" // todo - ignore space

type replacer func(data aggregateData) (old string, new string)

func main() {
	aggregate, err := findAggregate("Account", "UUID")
	if err != nil {
		panic(err)
	}

	spew.Dump(aggregate)

	templateFile(
		"/home/robert/src/icedrill/generator/placeholder/template.go",
		aggregate,
		[]replacer{
			func(data aggregateData) (string, string) { return "AggregateID", data.IDType },
			func(data aggregateData) (string, string) { return "AggregateType", data.Type },
			func(data aggregateData) (old string, new string) {
				handlers := ""
				for _, eventName := range data.Events {
					handlers += fmt.Sprintf("case %s:a.%s%s(v)\n", eventName, HandlerPrefix, eventName)
				}
				handlers = strings.TrimRight(handlers, "\n")

				return FunctionHandlersPlaceholder, handlers
			},
		},
	)
	templateFile(
		"/home/robert/src/icedrill/generator/eventstore/memory/template.go",
		aggregate,
		[]replacer{
			func(data aggregateData) (string, string) { return "placeholder.AggregateID", data.IDType },
			func(data aggregateData) (string, string) { return "placeholder.AggregateType", data.Type },
			func(data aggregateData) (string, string) {
				return "aggregate.AggregateID", "aggregate." + data.IDGetter
			},
			func(data aggregateData) (string, string) {
				return "NewAggregateTypeFromHistory", "New" + data.Type + "FromHistory"
			},
		},
	)
}

func templateFile(
	file string,
	aggregate aggregateData,
	replacers []replacer,
) {
	commnTpl, err := ioutil.ReadFile(file)
	if err != nil {
		panic(err)
	}
	commnTplStr := string(commnTpl)

	for _, replacer := range replacers {
		old, new := replacer(aggregate)
		commnTplStr = strings.ReplaceAll(commnTplStr, old, new)
	}

	p, err := format.Source([]byte(commnTplStr))
	if err != nil {
		panic(err)
	}

	fmt.Println("// Code generated by icedrill. DO NOT EDIT.\n\n" + string(p))
}

type aggregateData struct {
	Package          string
	Type             string
	IDGetter         string
	IDType           string
	Events           []string
	HaveEventSourced bool
}

func findAggregate(name string, idGetterName string) (aggregateData, error) {
	aggregate := aggregateData{
		IDGetter: idGetterName,
		Type:     name,
	}

	err := filepath.Walk(".", func(path string, fi os.FileInfo, err error) error {
		if fi.IsDir() {
			return nil
		}

		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			panic(err)
		}

		fmt.Println(f.Name)
		aggregate.Package = f.Name.Name

		for _, decl := range f.Decls {
			switch typeDecl := decl.(type) {
			case *ast.GenDecl:
				for _, spec := range typeDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						logger.Println(typeSpec, "is not *ast.TypeSpec")
						continue
					}

					if typeSpec.Name.Name != name {
						logger.Println(typeSpec.Name, "is not", name)
						continue
					}

					structDecl, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						// todo - error?
						logger.Println(typeSpec.Name, "is not struct")
						continue
					}

					for _, field := range structDecl.Fields.List {
						// todo - validate if proper field is present
						fmt.Println("field", field.Names, field.Type)
					}

					fmt.Println(typeSpec.Name)
				}
			case *ast.FuncDecl:
				logger.Println("Found func", typeDecl.Name)

				receiverType, err := getReceiverType(typeDecl)
				if err != nil {
					logger.Println(typeDecl.Name, ":", err)
					continue
				}

				if receiverType != name {
					logger.Println(typeDecl.Name, "have different receiver (", receiverType, ") skipping")
					continue
				}

				if strings.HasPrefix(typeDecl.Name.Name, HandlerPrefix) {
					logger.Println(typeDecl.Name, "is event handler")
					aggregate.Events = append(aggregate.Events, strings.ReplaceAll(typeDecl.Name.Name, HandlerPrefix, ""))
				}
				if typeDecl.Name.Name == idGetterName {
					logger.Println(typeDecl.Name, "is id getter")

					t, err := getType(typeDecl.Type.Results.List[0].Type)
					if err != nil {
						// todo - handle in better way
						panic(err)
					}

					if aggregate.IDType != "" {
						panic("IDType already set")
					}
					aggregate.IDType = t
				}
			}
		}

		return nil
	})

	if err != nil {
		return aggregateData{}, err
	}

	return aggregate, nil
}

func getReceiverType(typeDecl *ast.FuncDecl) (string, error) {
	if typeDecl.Recv == nil {
		return "", fmt.Errorf("%s have no receiver (nil)", typeDecl.Name)
	}

	if len(typeDecl.Recv.List) == 0 {
		return "", fmt.Errorf("%s have no receiver (empty list)", typeDecl.Name)
	}

	receiver := typeDecl.Recv.List[0].Type

	return getType(receiver)
}

func getType(expr ast.Expr) (string, error) {
	switch receiverType := expr.(type) {
	case *ast.StarExpr:
		return receiverType.X.(*ast.Ident).Name, nil
	case *ast.Ident:
		return receiverType.Name, nil
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", receiverType.X.(*ast.Ident), receiverType.Sel.Name), nil
	}

	return "", errors.Errorf("unsupported receiver %#v", expr)
}
