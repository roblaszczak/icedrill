package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/davecgh/go-spew/spew"
	"github.com/gobuffalo/packr"
	"github.com/pkg/errors"
)

var logger = log.New(os.Stderr, "[icedrill] ", log.LstdFlags)

const HandlerPrefix = "handle"

func main() {
	// todo - support dynamic templates
	box := packr.NewBox("../../templates")

	aggregatePtr := flag.String("aggregate", "", "aggregate name")
	idGetterPtr := flag.String("id-getter", "", "aggregate ID getter method")
	eventstore := flag.String("eventstore", "", "eventstore template to use")
	eventstoreDirectory := flag.String("eventstore-dir", ".", "directory, where put generated event store")

	flag.Parse()

	if *aggregatePtr == "" {
		panic("missing -aggregate")
	}
	if *idGetterPtr == "" {
		panic("missing -id-getter")
	}
	if *eventstore == "" {
		panic("missing -eventstore")
	}

	aggregateData, err := findAggregate(*aggregatePtr, *idGetterPtr)
	if err != nil {
		panic(err)
	}

	if *eventstoreDirectory != "." {
		aggregateData.InfraInDifferentPackage = true

	}

	spew.Dump(aggregateData)

	templateFile(
		"common/common.tpl",
		"domain_generated.go",
		box,
		aggregateData,
	)

	// todo - fix it
	if aggregateData.InfraInDifferentPackage {
		aggregateData.AggregateTypesPrefix = aggregateData.AggregatePackage + "."
	}
	spew.Dump(aggregateData)

	templateFile(
		fmt.Sprintf("eventstore/%s/template.tpl", *eventstore),
		filepath.Join(*eventstoreDirectory, "repo_generated.go"),
		box,
		aggregateData,
	)
}

func templateFile(
	tplFile string,
	dest string,
	box packr.Box,
	aggregate aggregateData,
) {
	tpl, err := box.FindString(tplFile)
	if err != nil {
		panic(err)
	}

	t := template.Must(template.New("tpl").Parse(tpl))

	b := bytes.NewBuffer(nil)

	if err := t.Execute(b, aggregate); err != nil {
		panic(err)
	}

	err = ioutil.WriteFile(
		dest,
		append([]byte("// Code generated by icedrill. DO NOT EDIT.\n\n"), b.Bytes()...),
		0644,
	)
	if err != nil {
		panic(err)
	}
}

type aggregateData struct {
	AggregateTypesPrefix    string
	AggregatePackage        string
	AggregateType           string
	IDGetter                string
	IDType                  string
	Events                  []string
	HaveEventSourced        bool
	InfraInDifferentPackage bool
}

func findAggregate(name string, idGetterName string) (aggregateData, error) {
	aggregate := aggregateData{
		IDGetter:      idGetterName,
		AggregateType: name,
	}

	err := filepath.Walk(".", func(path string, fi os.FileInfo, err error) error {
		if fi.IsDir() {
			return nil
		}

		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			panic(err)
		}

		spew.Dump(f.Package)

		fmt.Println(f.Name)
		aggregate.AggregatePackage = f.Name.Name

		for _, decl := range f.Decls {
			switch typeDecl := decl.(type) {
			case *ast.GenDecl:
				for _, spec := range typeDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						logger.Println(typeSpec, "is not *ast.TypeSpec")
						continue
					}

					if typeSpec.Name.Name != name {
						logger.Println(typeSpec.Name, "is not", name)
						continue
					}

					structDecl, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						// todo - error?
						logger.Println(typeSpec.Name, "is not struct")
						continue
					}

					for _, field := range structDecl.Fields.List {
						// todo - validate if proper field is present
						fmt.Println("field", field.Names, field.Type)
					}

					fmt.Println(typeSpec.Name)
				}
			case *ast.FuncDecl:
				logger.Println("Found func", typeDecl.Name)

				receiverType, err := getReceiverType(typeDecl)
				if err != nil {
					logger.Println(typeDecl.Name, ":", err)
					continue
				}

				if receiverType != name {
					logger.Println(typeDecl.Name, "have different receiver (", receiverType, ") skipping")
					continue
				}

				if strings.HasPrefix(typeDecl.Name.Name, HandlerPrefix) {
					logger.Println(typeDecl.Name, "is event handler")
					aggregate.Events = append(aggregate.Events, strings.ReplaceAll(typeDecl.Name.Name, HandlerPrefix, ""))
				}
				if typeDecl.Name.Name == idGetterName {
					logger.Println(typeDecl.Name, "is id getter")

					t, err := getType(typeDecl.Type.Results.List[0].Type)
					if err != nil {
						// todo - handle in better way
						panic(err)
					}

					if aggregate.IDType != "" {
						panic("IDType already set")
					}
					aggregate.IDType = t
				}
			}
		}

		return nil
	})

	if err != nil {
		return aggregateData{}, err
	}

	return aggregate, nil
}

func getReceiverType(typeDecl *ast.FuncDecl) (string, error) {
	if typeDecl.Recv == nil {
		return "", fmt.Errorf("%s have no receiver (nil)", typeDecl.Name)
	}

	if len(typeDecl.Recv.List) == 0 {
		return "", fmt.Errorf("%s have no receiver (empty list)", typeDecl.Name)
	}

	receiver := typeDecl.Recv.List[0].Type

	return getType(receiver)
}

func getType(expr ast.Expr) (string, error) {
	switch receiverType := expr.(type) {
	case *ast.StarExpr:
		return receiverType.X.(*ast.Ident).Name, nil
	case *ast.Ident:
		return receiverType.Name, nil
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", receiverType.X.(*ast.Ident), receiverType.Sel.Name), nil
	}

	return "", errors.Errorf("unsupported receiver %#v", expr)
}
